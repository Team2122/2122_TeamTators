{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Tator Tome","text":"<p>Welcome to the Tator Tome! This site is home to the documentation that Team 2122 has compiled over the years to give students and mentors alike a reference point to maintain consistent, quality codebases, as well as document various processes that may be useful.</p> <p>Other useful documentation sites can be found here:</p> <ul> <li>WPILib Documentation</li> <li>CTRE/Phoenix API Documentation</li> <li>Rev API Documentation</li> <li>AdvantageKit Documentation</li> <li>Choreo Documentation (both app and library)</li> <li>Another website with more documentation links!</li> </ul>"},{"location":"Miscellaneous/Drive%20Practice%20Setup%20for%20Mechanical/","title":"Drive Practice Setup for Mechanical Students","text":"AKA How To Get The Robot To Drive Without Being A Programmer <pre><code>// TODO intro\n</code></pre>"},{"location":"Miscellaneous/Drive%20Practice%20Setup%20for%20Mechanical/#step-0-login","title":"Step 0: Login","text":"<ol> <li>Log in to the laptop with the PIN of 2122.</li> <li>Connect to a mobile hotspot or a Wi-Fi with actual internet (not the robot).</li> </ol>"},{"location":"Miscellaneous/Drive%20Practice%20Setup%20for%20Mechanical/#step-1-open-the-robot-project","title":"Step 1: Open the Robot Project","text":"<ol> <li>Open the \"{this year} WPILib VS Code\" (e.g. 2024 WPILib VS Code)</li> <li>Check the top of the window:    If it has the name of the robot you're working with, great. Otherwise, check File &gt; Open Recent for the repo, else File &gt; Open Folder and open whichever one of these paths exists:<ul> <li><code>C:\\Code\\&lt;robot name here&gt;</code></li> <li><code>C:\\Users\\senti\\Code\\&lt;robot name here&gt;</code></li> <li><code>C:\\Users\\&lt;other users&gt;\\Code\\&lt;robot name here&gt;</code>   If none exist, it may not be on that laptop. Check the other one.</li> </ul> </li> </ol>"},{"location":"Miscellaneous/Drive%20Practice%20Setup%20for%20Mechanical/#step-2-fetch","title":"Step 2: Fetch","text":"<ol> <li>Once you have the correct robot code open, press Ctrl+Shift+` to open a terminal.</li> <li>Type <code>git fetch</code> into the terminal (at the bottom) and press Enter.</li> <li>Check the output:</li> <li>If it has <code>Could not resolve hostname</code>, make sure you're connected to the internet and try again.</li> <li>If the last line is like <code>Unpacking objects: 100% (XX/XX), XX.XX KiB | X.XX MiB/s, done.</code>, you've successfully fetched. Continue to the next step.</li> <li>If there was no output (if it just gave you another prompt), you're already up to date. Continue to the next step.</li> </ol>"},{"location":"Miscellaneous/Drive%20Practice%20Setup%20for%20Mechanical/#step-3-select-tag","title":"Step 3: Select Tag","text":"<ol> <li>With the terminal still open, type in <code>git tag</code> and press Enter.</li> <li>It should list tags from newest to oldest. Note the name of the most recent (topmost) one with a name containing \"drive practice\" or something similar.</li> <li>Type in <code>git checkout &lt;name of tag&gt;</code> and press Enter.</li> <li>Check the output:</li> <li>If it ends with <code>HEAD is now at &lt;whatever&gt;</code>, you're good. Continue to the next step.</li> <li>If it ends with <code>Please commit your changes or stash them before you switch branches.</code>, type <code>git stash</code>, hit Enter, and retry the checkout.</li> <li>If it starts with <code>error: you need to resolve your current index first</code>, type <code>git add .</code> and hit Enter. Then type <code>git stash</code>, hit Enter, complain to Programming for leaving you a merge conflict, then try the checkout again.</li> </ol>"},{"location":"Miscellaneous/Drive%20Practice%20Setup%20for%20Mechanical/#step-4-deploy","title":"Step 4: Deploy","text":"<ol> <li>Find the WPILib \\ near the upper right and click it: <p>If the button isn't present, open the Command Palette with Ctrl+Shift+P</p> <ol> <li>Find the \"WPILib: Deploy Robot Code\" option (if you opened the command palette, you can type in \"wpilib\" and it should show up) and click it.</li> <li>If it asks you to \"Pick a language\", choose Java.</li> <li>Wait for it to deploy, and check the output:<ul> <li>If it ends with <code>BUILD SUCCESSFUL</code>, the code deployed. Continue to the next step.</li> <li>If it ends with <code>BUILD FAILED</code>, the deploy failed. Look through the output and find <code>* What went wrong:</code> to see why (you may need to scroll):</li> <li><code>Execution failed for task ':discoverroborio'.</code>: You aren't connected to the robot.</li> <li><code>Execution failed for task ':compileJava'.</code>: There's an error in the code. Go back to a terminal, type <code>git stash</code>, hit Enter, and then try again. If it still fails, contact Programming.</li> <li>Anything else: Hopefully the message is helpful?</li> </ul> </li> </ol>"},{"location":"Miscellaneous/Drive%20Practice%20Setup%20for%20Mechanical/#step-5-drive","title":"Step 5: Drive","text":"<ol> <li>Open the FRC Driver Station app.</li> <li>Verify that the robot is connected and has code loaded (\"Communications\" and \"Robot Code\" should both have fully green boxes next to them)</li> <li>Switch to the Devices tab () (on the left, USB icon) and make sure that your driver controller appears on slot 0 (pressing buttons should make it light up), and your gunner controller (if any) on slot 1. If not, drag and drop to reorder.</li> <li>Make sure you can easily hit Enter (disable) or Space (E-stop) if needed. (If you E-Stop, you'll need to redeploy the robot code.)</li> <li>Switch back to the Operation tab (), select TeleOperated mode, and press Enable to start the robot.</li> </ol>"},{"location":"Miscellaneous/Making%20a%20Backup%20SD%20Card%20at%20a%20Competition/","title":"Making an SD Card Backup at a Competition","text":"<p>When the robot's code is modified during a competition, we back up the new code on an SD card.</p>"},{"location":"Miscellaneous/Making%20a%20Backup%20SD%20Card%20at%20a%20Competition/#reimaging-the-card","title":"Reimaging the Card","text":"<p>This should happen before the start of qualifying matches and before the start of playoff matches.</p> <p>On a Tators laptop:</p> <ol> <li>Use balenaEtcher to re-image the SD card. To find the SD card image on Windows:<ul> <li>Right click on the \"roboRIO Imaging Tool\" icon and select \"Open file location\" from the pop-up menu.</li> <li>Browse to the \"FRC Images\" &gt; \"SD Images\" directory in the same location as the \"roboRIO_ImagingTool\" application.</li> </ul> </li> <li>Use roboRIO Team Number Setter to set our team number (<code>2122</code>) on the SD card. See https://docs.wpilib.org/en/stable/docs/software/wpilib-tools/roborio-team-number-setter/index.html</li> </ol>"},{"location":"Miscellaneous/Making%20a%20Backup%20SD%20Card%20at%20a%20Competition/#updating-code-on-an-sd-card","title":"Updating Code on an SD Card","text":"<p>This should happen every time a commit is made to the event branch for that day.</p> <p>On a mobile phone:</p> <ol> <li>Make sure the hotspot is enabled and allows external devices to join.</li> </ol> <p>On a Tators laptop:</p> <ol> <li>Join the hotspot.</li> <li>Open a terminal window.</li> <li><code>git checkout [branch that has code changes]</code></li> <li><code>git pull</code></li> <li>Leave the terminal window open. You will use it again below.</li> </ol> <p>Back on the mobile phone:</p> <ol> <li>You may disable the hotspot.</li> </ol> <p>With roboRIO device:</p> <ol> <li>Make sure the roboRIO is unplugged from its power source.</li> <li>Connect a USB cable between Tators laptop and roboRIO.</li> <li>Insert an imaged SD card.</li> <li>Plug the roboRIO back into its power source.</li> <li>To check if the USB connection is working, <code>ping 172.22.11.2</code>. The response should show packets being transmitted rather than a request timeout.</li> </ol> <p>On the laptop:</p> <ol> <li>In Visual Studio Code, deploy the robot code by choosing the \"WPILib:Deploy robot code\" menu item (Ctrl+Shift+P) or clicking the WPILib icon in the top, right corner.</li> <li>Watch the progress of the deployment in the driver\u2019s station dashboard.</li> <li>When deployment is done, unplug the roboRIO from its power source.</li> <li>Remove the SD card.</li> <li>In the terminal window, <code>git log --max-count 1</code> (shows the current commit hash, after the word \"commit\" on the first line of output)</li> </ol> <p>With SD card:</p> <ol> <li>With a small piece of tape and a Sharpie, label the card with the first 4 characters of the commit hash of the code changes and the date/time the backup was made.</li> </ol>"},{"location":"Miscellaneous/Robot%20Names/","title":"Robot Names","text":"<p>Repo names match bot names unless otherwise specified.</p>"},{"location":"Miscellaneous/Robot%20Names/#2025","title":"2025:","text":"<ul> <li>Onseason: Tidaltator</li> </ul>"},{"location":"Miscellaneous/Robot%20Names/#2024","title":"2024:","text":"<ul> <li>Flatbot: MashedPotator</li> <li>Onseason: Conductator</li> <li>Offseason: TatorSwift</li> </ul>"},{"location":"Miscellaneous/Robot%20Names/#2023","title":"2023:","text":"<ul> <li>Onseason: Washatator</li> <li>Offseason: Imitator in the repo <code>2023_OffSeason</code></li> </ul>"},{"location":"Miscellaneous/Robot%20Names/#2022","title":"2022:","text":"<ul> <li>Onseason: TransporTator</li> <li>Offseason: SassiTator</li> </ul>"},{"location":"Miscellaneous/Swerve%20Tuning/","title":"Swerve Tuning","text":"<p>Swerve wheels consist of two parts: the azimuth controls where the wheel points, while the drive actually runs the wheels. Both parts need to be well-tuned for a robot to drive well (though it's not hard to get azimuth well-tuned).</p>"},{"location":"Miscellaneous/Swerve%20Tuning/#step-1-put-the-robot-on-blocks","title":"Step 1: Put the robot on blocks","text":"<p>For tuning the azimuths, the robot needs to be off the ground. Get some blocks (there's a bin with plastic blocks of various shapes somewhere in the shop that works nicely, other kinds of blocks will also work) and use them to get the robot off the ground. Make sure the wheels won't hit or grip anything when rotating + driving.</p>"},{"location":"Miscellaneous/Swerve%20Tuning/#step-2-align-the-azimuths","title":"Step 2: Align the Azimuths","text":"<p>The azimuths need to be tuned such that, if the drive motors are driving in a positive direction and the azimuth motors are at an angle of 0, the robot should drive forwards.  </p> <p>Before tuning, we want to deploy Phoenix's temporary diagnostic server. It will do absolutely nothing, which is great when you don't want the motors to move while you're tuning them.</p> <ol> <li>If there isn't any robot code, Phoenix will readily offer to deploy the diagnostic server in the Devices menu. Click the RUN TEMPORARY DIAGNOSTICS button.  </li> </ol> <p></p> <ol> <li>If there is other robot code, or if the button otherwise dosen't show up, go to the Settings menu from the hamburger menu in the upper left.</li> <li>Expand the \"FRC Advanced\" section and click \"Run Temporary Diagnostic Server\".</li> </ol> <p>After the temporary diagnostic server is running, do the following for each wheel:</p> <ol> <li>Find the Cancoder for that wheel in Phoenix Tuner X. Make sure you've got the right one by using the Blink button.</li> <li>Go into the Config tab and set the Magnet Offset to 0. Use the \"Apply and flash configs\" button () to save the config.</li> <li>Turn the wheel so that it's aligned forward-backward (don't worry about if it's inverted yet). The shop has a swerve alignment tool; use it if possible.</li> <li>Go to the Self Test tab and click Refresh; this should load a page. Copy the Absolute Position value (only the number), flip the sign (positive to negative and vice versa), and paste it into the Magnet Offset field in the config.</li> <li>Flash the config. Make sure the offset is correct by refreshing the Self Test and checking that the Absolute Position is now near-zero (within \u00b10.01 is good).</li> <li>Find the drive motor for the current wheel.</li> <li>Go to the Control panel and set the control mode to VoltageOut (below the big red DISABLED button), and set the Output to a very small value (just below 0.5V is good).</li> <li>Enable the robot in Test mode.</li> <li>Click the DISABLED button to enable Phoenix control and run the wheel. If the wheel would push the robot forward (it would push the ground backwards), great! Disable the motor control and skip this step. If not:<ol> <li>Disable motor control, then go back to the Cancoder and go to the Config tab.</li> <li>If the magnet offset is negative, add 0.5, else subtract 0.5. Flash the config.</li> </ol> </li> <li>Make sure to save the magnet offset in code if it's saved there.</li> <li>Swerve wheels are generally not perfectly symmetrical. Check for something that's on one side of the wheel only, and use that information to get the wheel angle right the first time for the rest of the wheels.</li> </ol> <p>After tuning all the azimuths, verify by going either into Manual Tests and using the <code>SwerveTuningTest</code> to drive the wheels, or going into Teleop and just driving in that mode.</p>"},{"location":"Miscellaneous/Swerve%20Tuning/#step-3-drive-motor-tuning","title":"Step 3: Drive Motor Tuning","text":"<p>Tuning the drive motors ensures that the bot drives at the correct speed.</p> <ol> <li>Get the bot off blocks and on the ground. The tuning will be very different if the wheels aren't pushing a bot.</li> <li>Make sure that the <code>SwerveTuningTest</code> manual test is available in the swerve subsystem.</li> <li>Go into Test mode and select the <code>SwerveTuningTest</code> test.</li> <li>Open up Shuffleboard or similar tool, and look under the <code>quick/SwerveTuning</code> path for PID values.</li> <li>First, tune S.<ol> <li>Start it at a small guess value (e.g. 0.5V).</li> <li>Increase S if the bot doesn't move, decrease S if it does.</li> <li>Repeat until S is just barely not enough to move the robot.</li> </ol> </li> <li>Next, tune V.<ol> <li>You'll need to look at the <code>DesiredSpeed</code> and <code>ActualSpeed</code> values under the <code>quick/SwerveTuning</code> table, preferrably as a graph; open AdvantageScope, connect to the robot (Ctrl-K), and put those two values into a graph.</li> <li>Start V at a small guess value (0.01).</li> <li>Increase V if the bot goes too slow, decrease V if it's too fast. Make sure to test moving around as well as rotating.</li> <li>Repeat until the bot drives roughly the speed it's being told to. Don't worry about getting this extremely accurate; that's what P and D are for.</li> </ol> </li> <li>Now, tune P.<ol> <li>Find some sort of weight to add to the robot, e.g. a stack of cones. Place it on the robot.</li> <li>Start P at the same value as V.</li> <li>Increase to increase snappiness, decrease if the wheels make scary noises due to jittering. Make sure to test moving around as well as rotating.</li> <li>Repeat until it's low enough to consistently avoid scary noises.</li> <li>Test that the robot still moves well with the weight removed.</li> </ol> </li> <li>Finally, tune D.<ol> <li>TODO figure out how to use D properly; it seems to just make the wheels jitter when I try to use it. (For future refrence I started it at 1/100th and it instantly caused jitter.)</li> </ol> </li> <li>Remeber to save P/D/S/V values to code.</li> </ol>"},{"location":"Miscellaneous/Swerve%20Tuning/#step-4-azimuth-tuning","title":"Step 4: Azimuth Tuning","text":"<p>The azimuth motors are usually just so overpowered that it's very easy to get it very close. If the azimuths don't appear to be poorly tuned, you probably don't need to retune them.</p> <ol> <li>Go back into that <code>SwerveTuningTest</code> test and hit Back/Select to swap to azimuth mode.</li> <li>Replace the P/D/S/V values with the ones currently in code for the azimuths. (which probably just has P set.)</li> <li>If the azimuths aren't turning very fast, increase P. If they're going crazy, decrease P.</li> <li>Repeat until it gets to its setpoint fairly quickly (say, under 0.3s)</li> <li>Remeber to save P/D/S/V values to code.</li> </ol>"},{"location":"Programming/Device%20Health%20Manager/","title":"Device Health Manager","text":"<p>The device health manager is a system for logging when things go wrong in subsystems, e.g. when a motor/sensor gets disconnected or has an error.</p>"},{"location":"Programming/Device%20Health%20Manager/#how-it-works","title":"How it works","text":"<p>Each subsystem must implement <code>getHealth()</code>: <pre><code>@Override\npublic boolean getHealth() {\n    // should return `true` if the system is fine and `false` if something is disconnected/not working\n    return isEverythingFine;\n}\n</code></pre></p> <p>The <code>DeviceHealthManager</code> will go through each subsystem and log if a system reports itself as unhealthy. <code>Robot.java</code> should call <code>DeviceHealthManager.logHealth()</code> every tick and <code>DeviceHealthManager.printHealth(currentControlMode)</code> when going into Disabled from another state.</p> <p>There are two fault states it keeps:</p> <ul> <li>Current faults only record what's unhealthy right now; if a system recovers the current fault for it will disappear</li> <li>Sticky faults will persist even if the system recovers; useful for knowing if a system went down at all during a match.</li> </ul>"},{"location":"Programming/Device%20Health%20Manager/#where-it-logs","title":"Where it logs","text":"<p>The <code>DeviceHealthManager</code> will log the status of motors and sensors in the driver station's console when the robot disables. <pre><code>===== ROBOT HEALTH REPORT =====\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; From Teleop\nCurrent faults: none\nSticky faults: Pivot, Affector\n===============================\n</code></pre></p> <p>It will also continuously log the faults to NetworkTables under <code>AdvantageKit/Health/</code>:</p> <ul> <li><code>Health/Momentary/Healthy</code> will be true if nothing is currently having issues.</li> <li><code>Health/Sticky/Healthy</code> will be true if nothing has had issues at all during the match.</li> <li><code>Health/Momentary/Faults</code> and <code>Health/Sticky/Faults</code> will log exactly what systems have/had issues, or \"nothing\" if no issues are/were detected.</li> </ul>"},{"location":"Programming/RepulsorFieldPlanner/","title":"Repulsor Field Planner or: Obstacle Avoidance via Vector Field","text":""},{"location":"Programming/RepulsorFieldPlanner/#introduction","title":"Introduction","text":"<p><code>RepulsorFieldPlanner.java</code> is a file used in the codebase of a robot that calculates what direction to go in order to reach a goal on the field, given the fact that there are obstacles in the way. A lot of the math may seem unapproachable or overwhelming at first, but so long as you're willing to put some effort into reading this document and learning some things, I'm sure you'll see it's not too bad.</p> <p>This document is designed to help a student, whether rookie or veteran, mathematically inclined or averse, understand what <code>RepulsorFieldPlanner.java</code> is meant to solve, how it solves that problem, and how to use it. Please be inclined to ask questions to mentors or other students should you have any questions or confusions. The team is here to help you, and so is this document.</p>"},{"location":"Programming/RepulsorFieldPlanner/#what-is-repulsorfieldplannerjava","title":"What is <code>RepulsorFieldPlanner.java</code>?","text":"<p>Originally designed during the 2025 competition season, the file arose from the wider FRC community, not specifically from Team Tators. In particular, the original derivation (which can be found here) used in our codebase comes from Children of the Corn, team #167. This document, however, is unique to our team. In 2025, there was a large hexagonal obstacle in the middle of each alliance's side of the field that the robot had to place on, and it was soon realized that automating the entire placement process (i.e. the robot takes control of driving the moment a gamepiece was picked) would be a lot faster than the standard manual driving approach employed in years past. However, the easy way of driving in a straight line from point A to point B wouldn't quite cut it, since, as mentioned previously, there was a large hexagonal obstacle in the way. Thus, obstacle avoidance was born.</p>"},{"location":"Programming/RepulsorFieldPlanner/#how-does-repulsorfieldplannerjava-work","title":"How Does <code>RepulsorFieldPlanner.java</code> Work?","text":"<p>But how does one avoid obstacles? It's a somewhat difficult problem to think about, really. In the past, the typical approach to driving to a point, not considering obstacles, was to just use a simple PID control loop on your robot's position to drive it to a specific point. The new idea amongst the community was to define something called a vector field to represent the field.</p>"},{"location":"Programming/RepulsorFieldPlanner/#intro-to-vector-fields","title":"Intro to Vector Fields","text":"<p>If you're somebody who has not taken calculus yet, then that link leading to a calculus textbook may seem scary. If you want to continue learning and improving, you need to eviscerate that thought and eject it far from your soul. I've been there, and I can tell you the thought of \"this math is too complicated\" is not true. A vector field is literally just a bunch of arrows that point somewhere. Some arrows are longer than others, and so they're stronger than the other arrows, and whatever thing is there will experience a greater force in that direction. Why this is considered high level math is beyond me.</p> <p>Vector fields are used widely in mathematics and physics, such as when modelling a gravitational or magnetic field, but they are conceptually easy to understand. If you've taken AP Calculus, you might be familiar with a slope field, which is close to what a vector field is. Slope fields define the direction for a function to travel, while a vector field defines the direction and strength with which to follow, as vectors have direction and magnitude.</p> <p>For example, look at the following gif, and glance upon the many arrows drawn in the hurricane. Now imagine you're something in that hurricane. Pick a point and try following its path with your finger. Pay attention to the speed and direction of your movement, and see how it matches up with the length and direction of the arrows near your finger. This is the same way the robot follows the vector fields defined in <code>RepulsorFieldPlanner.java</code>.</p> <p></p> <p>Keep in mind that, although vector fields are often visualized with grids of arrows whose positions are fixed, a vector field is typically a continuous function, and the grid of arrows is simply an easy way to visualize a function \\(\\vec{F}(x, y)\\), where \\(\\vec{F}\\) is a vector with direction and magnitude in a two dimensional plane. The visual grid of arrows is not a literal definition of a vector field, but more just a helpful way to visualize many outputs of a continuous function.</p>"},{"location":"Programming/RepulsorFieldPlanner/#visualization","title":"Visualization","text":"<p>To visualize the vector field you're creating, there's a function in <code>RepulsorFieldPlanner.java</code> called <code>getArrows()</code>, which returns an array of <code>Pose2d</code>s. When logged properly (this logging should only happen in simulation, as the computation is somewhat expensive), the array can be visualized in AdvantageScope's odometry or 3D field tab. For reasons explained below, there are three different types of vector fields one can draw: goal, obstacle, and sum. The <code>VectorField</code> enum can be passed into <code>getArrows</code> to determine which field to visualize.</p> <p>Another point of note is that, due to technical limitations in AdvantageScope, the strength of vectors cannot be visualized. Only <code>Pose2d</code>s have translational and rotational data that can be visualized, but a <code>Pose2d</code> is meant to depict a point, not a vector, and thus has no way to configure the strength of the vector depicted by one.</p>"},{"location":"Programming/RepulsorFieldPlanner/#final-algorithm","title":"Final Algorithm","text":"<p>There are really two vector fields at play here. There is a vector field that points away from obstacles, and there is a vector field that points toward the goal. They use an inverse square (\\(\\vec{F} \\propto \\frac{1}{x^2}\\)) and proportional strength (\\(\\vec{F} \\propto x\\)) relationship, respectively. Thus, the closer to an obstacle the robot is, the harder it will drive away, and the closer the robot is to the goal, the less it will drive towards it.</p> <p>The final vector is computed by simply adding the resultant vector from each field together, like so:</p> <ol> <li>Compute the vector from field obstacle vector field</li> <li>Compute the vector from goal position vector field</li> <li>Add these two vectors together</li> </ol> <p>The final step produces a vector that both drives the robot away from obstacles and drives toward a goal. Step 1 is represented by the function <code>getObstacleForce()</code>, step 2 by <code>getGoalForce()</code>, and step 3 by <code>getForce()</code> in the code. It really is that simple.</p>"},{"location":"Programming/RepulsorFieldPlanner/#how-do-i-use-repulsorfieldplannerjava","title":"How Do I Use <code>RepulsorFieldPlanner.java</code>?","text":"<p>A few things have to happen before one can avoid obstacles. First, create a repulsor where you plan on using one (typically just within the drive subsystem).</p> <pre><code>RepulsorFieldPlanner repulsor = new RepulsorFieldPlanner();\n</code></pre> <p>Next, when you want to declare where to travel to, you must tell the repulsor where that is.</p> <pre><code>// `goal` here is a Pose2d that is assumed to be already known\nrepulsor.setGoal(goal.getTranslation());\n</code></pre> <p>Finally, the repulsor has to be periodically sampled, since the robot is constantly moving throughout the vector field, changing the vector calculated. <code>sampleField</code> is a function that will return a <code>RepulsorSample</code>, which is a custom data type that does nothing more than hold three values: <code>intermediateGoal</code>, <code>vx</code>, and <code>vy</code>. <code>vx</code> and <code>vy</code> can be used as feedforward values for the robot velocity, and <code>intermediateGoal</code> can be used in a feedback loop to compute a more accurate following of the vector field. If you do not know what \"feedforward\" or \"feedback\" are, please refer to this useful page on control theory in the WPILib documentation (the provided link points to block diagrams, as that's where feedforward (or \"open-loop\") and feedback (\"closed-loop\") are diagrammed, but the entire page is worth a read)</p> <pre><code>/* this entire snippet should be called periodically */\n\nPose2d pose = getPose();\n\nRepulsorSample sample = repulsor.sampleField(\n    pose.getTranslation(), // translational position of the robot\n    3.5, // max speed of the robot in meters per second when following the vector field\n    0.8 // distance of the robot in meters from the goal before linearly interpolating a slowdown to 0 m/s\n);\n\nChassisSpeeds feedforward = new ChassisSpeeds(sample.vx(), sample.vy(), 0);\n\nChassisSpeeds feedback = new ChassisSpeeds(\n    transController.calculate(\n        pose.getTranslation().getX(),\n        sample.intermediateGoal().getX()),\n    transController.calculate(\n        pose.getTranslation().getY(),\n        sample.intermediateGoal().getY()),\n    rotController.calculate(\n        pose.getTranslation().getRotation().getRadians(),\n        goal.getRotation().getRadians())\n);\n\nChassisSpeeds output = feedforward.plus(feedback);\n</code></pre> <p>And then, if you actually use the <code>output</code> object, you will have obstacle avoidance. It wasn't that hard, right?</p>"},{"location":"Programming/RepulsorFieldPlanner/#adapting-from-year-to-year","title":"Adapting From Year to Year","text":"<p><code>RepulsorFieldPlanner.java</code> has many different obstacle types defined in it, but you may need to formulate more depending on the field. For example, <code>TeardropObstacle</code> is a pretty unique shape (sort of like \"c&gt;\", like a raindrop), but forces the robot to move to the sides of a circular obstacle should the goal be on the opposite end of the obstacle from the robot. This was used to model the reef in the 2025 onseason. The reef was a big hexagon, so you may have to get creative with how you model obstacles to get a satisfactory result.</p> <p>It's also important that the obstacles be modified from year to year. Don't assume that copying the file verbatim from last year will work, since the robot will be avoiding last year's obstacles. It's likely there will be a file out there somewhere in the community (such as from 3173, 6995, or 167), so don't feel as though you have to be a genius at modelling in order to get a working solution. All obstacles should be defined as static objects near the instantiation of last year's obstacles, and the strength of obstacles may need to be tuned.</p>"},{"location":"Programming/Documentation/","title":"The Documentation Documentation","text":"<p>This document is aimed at describing the process by which this documentation site is built and published should it need be maintained in the future.</p> <p>The publishing sequence is pretty simple and goes as follows:</p> <ol> <li>A change to documentation is merged to main</li> <li>Github runs a CI job to run <code>mkdocs gh-deploy</code>, which builds the markdown    files into an HTML website and pushes the site to the <code>gh-pages</code> branch</li> <li>Github sees an update on the <code>gh-pages</code> branch and publishes the contents of    it to https://Team2122.github.io/2122_TeamTators</li> </ol> <p>How these are run will be explained in more detail in other pages.</p>"},{"location":"Programming/Documentation/deployment/","title":"Deployment","text":""},{"location":"Programming/Documentation/deployment/#ci-continuous-integration","title":"CI (Continuous Integration)","text":"<p>CI is what runs in order to get the little green check mark in this image:</p> <p></p> <p>What that green check mark means is that the documentation on that commit has been successfully built and deployed to the <code>gh-pages</code> branch. This process is defined in <code>.github/workflows/deploy-docs.yml</code>. What that file does is define a job that calls <code>mkdocs gh-deploy</code> and tells GitHub to run that job every time a commit is pushed the main branch. More info on <code>mkdocs gh-deploy</code> can be found on the MKDocs page or at the official MKDocs documentation</p>"},{"location":"Programming/Documentation/deployment/#github-pages","title":"GitHub Pages","text":"<p>The job of GitHub pages is to actually serve the documentation. GitHub pages is a service that allows you to host static HTML sites for free at <code>https://&lt;user&gt;.github.io/&lt;repository-name&gt;</code>.</p> <p>For this repository, GitHub pages is configured to deploy the contents of the <code>gh-pages</code> branch to this site anytime a commit is made to it. This enables the following workflow for automatic docs deployment:</p> <ul> <li>Changes are made to main</li> <li>CI automatically runs <code>gh-deploy</code>, which builds the site and pushes the output   to the <code>gh-pages</code>branch</li> <li>GitHub sees a change on the <code>gh-pages</code> branch and automatically pushes the   output to the Tator Tome website</li> </ul>"},{"location":"Programming/Documentation/mkdocs/","title":"MKDocs","text":"<p>MKDocs is the program used to take all of the markdown documentation files and compile them into a static HTML site. The MKDocs docs can be found here.</p> <p>You should install MKDocs if you want to debug the site.</p>"},{"location":"Programming/Documentation/mkdocs/#installation","title":"Installation","text":"<p>To install MKDocs, see MKDocs' installation page.</p> <p>If you are using Linux, you should ignore the above advice and just use your distribution's package manager.</p> <p>In order to install plugins, you can use the same installation method as above. For example, to install <code>mkdocs-material</code>, I would use the following:</p> <pre><code>pip install mkdocs-material\n</code></pre>"},{"location":"Programming/Documentation/mkdocs/#hacking","title":"Hacking","text":"<p>You can hack on the MKDocs build by adjusting the settings in mkdocs.yml. This file contains all of the settings MKDocs considers when compiling the site, such as the theme and plugins.</p> <p>One of the plugins used is called <code>mkdocs-material</code>. This provides both a nice looking theme and lots of easy to set up plugins. They have amazing documentation here</p> <p>With regards to running MKDocs, there are three important subcommands to know:</p> <ul> <li><code>serve</code></li> <li><code>build</code></li> <li><code>gh-deploy</code></li> </ul> <p>Each of these are called as <code>mkdocs &lt;command&gt;</code> in a terminal that has <code>mkdocs</code> installed. For example, to build the documentation, I would enter <code>mkdocs build</code> into my terminal.</p> <p>Each of these are expanded upon more below</p>"},{"location":"Programming/Documentation/mkdocs/#common-subcommands","title":"Common Subcommands","text":""},{"location":"Programming/Documentation/mkdocs/#serve","title":"Serve","text":"<p>The command <code>mkdocs serve</code> will both build the site and start a webserver on your machine you can connect to at <code>localhost:8000</code> in your browser. This should let you preview the site as it will be when it is published.</p> <p>The webpage in your browser will automatically update as you make changes to the documentation. You do not have restart this command while iterating on documentation.</p>"},{"location":"Programming/Documentation/mkdocs/#build","title":"Build","text":"<p>You can use <code>mkdocs build</code> to compile the documentation into its final form. By default, the site is output into a directory called <code>site</code>.</p>"},{"location":"Programming/Documentation/mkdocs/#gh-deploy","title":"GH Deploy","text":"<p>All <code>mkdocs gh-deploy</code> does is build the site and push the contents of the site to the <code>gh-pages</code> branch. It is very unlikely you will need to invoke this manually, and documented exclusively because it is used in the CI job that runs on every merge to main.</p>"},{"location":"Programming/Documentation/nix/","title":"Nix","text":"<p>Nix is a build tool and package repository that can be used to automatically create a development shell with all of the required tools inside of it: primarily, MKDocs and the plugins we use.</p> <p>The purpose of Nix is to provide a reproducible environment such that running <code>nix develop</code> (the command to enter the provided development shell) will give you the exact same shell with the exact same packages, all on the same versions as if you ran it 5 years ago or 5 years in the future.</p> <p>Nix is primarily used to power the CI for deploying the website.</p> <p>Nix is not required when debugging locally, and is only natively supported on Linux and Mac (although you can use it from within WSL on Windows).</p>"},{"location":"Programming/Documentation/nix/#why-nix","title":"Why Nix?","text":"<p>The point of using Nix in the CI is primarily because the plugin used to render <code>.excalidraw</code> files for MKDocs has an absolutely atrocious build system that involves building both the python plugin and the javascript rendering code. The original architect of this documentation repository also happened to get this building through Nix due to their personal workflow involving the tool, and replicating this in a GitHub actions runner without nix was a somewhat involved task, so Nix it was.</p> <p>Additionally, Nix provides a very convenient way to create reproducible shells to prevent future breakages in the CI.</p>"},{"location":"Programming/Documentation/nix/#how-nix","title":"How Nix?","text":"<p>Before beginning, I should note that Nix is a complicated language/tool/package repository. This document is aimed at describing what our Nix flake specifically does, not at explaining Nix as a whole. For more information on the nix language in general, see this introduction and followup on functions and imports. More information on flakes specifically can be found here.</p> <p>The first thing to understand about Nix is that it is first and foremost a package manager, \u00e0 la the Microsoft Store or Steam. However, Instead of clicking buttons to manage packages, packages are defined through a programming language also called Nix, and those packages can be used as the outputs of a Nix flake.</p> <p>The flake for this repository can be found in a file at the project root called <code>flake.nix</code>. Inside of this flake, you will find two primary sections: <code>inputs</code> and <code>outputs</code>. In Nix, the inputs of your flake are the dependencies of it, such as nixpkgs, the Nix package repository, among others. Your outputs are what you can actually use, such as packages or development shells.</p> <p>We define several outputs. Namely, at the time of writing, the <code>beautifulsoup4</code>, <code>excalidraw-renderer</code>, and <code>mkdocs-excalidraw</code> packages, as well as a <code>devShell</code> output. These can be visualized through the <code>nix flake show</code> command:</p> <pre><code>\u251c\u2500\u2500\u2500devShells\n\u2502   \u251c\u2500\u2500\u2500aarch64-darwin\n\u2502   \u2502   \u2514\u2500\u2500\u2500default omitted (use '--all-systems' to show)\n\u2502   \u251c\u2500\u2500\u2500aarch64-linux\n\u2502   \u2502   \u2514\u2500\u2500\u2500default omitted (use '--all-systems' to show)\n\u2502   \u251c\u2500\u2500\u2500x86_64-darwin\n\u2502   \u2502   \u2514\u2500\u2500\u2500default omitted (use '--all-systems' to show)\n\u2502   \u2514\u2500\u2500\u2500x86_64-linux\n\u2502       \u2514\u2500\u2500\u2500default: development environment 'nix-shell'\n\u2514\u2500\u2500\u2500packages\n    \u251c\u2500\u2500\u2500aarch64-darwin\n    \u2502   \u251c\u2500\u2500\u2500beautifulsoup4 omitted (use '--all-systems' to show)\n    \u2502   \u251c\u2500\u2500\u2500excalidraw-renderer omitted (use '--all-systems' to show)\n    \u2502   \u2514\u2500\u2500\u2500mkdocs-excalidraw omitted (use '--all-systems' to show)\n    \u251c\u2500\u2500\u2500aarch64-linux\n    \u2502   \u251c\u2500\u2500\u2500beautifulsoup4 omitted (use '--all-systems' to show)\n    \u2502   \u251c\u2500\u2500\u2500excalidraw-renderer omitted (use '--all-systems' to show)\n    \u2502   \u2514\u2500\u2500\u2500mkdocs-excalidraw omitted (use '--all-systems' to show)\n    \u251c\u2500\u2500\u2500x86_64-darwin\n    \u2502   \u251c\u2500\u2500\u2500beautifulsoup4 omitted (use '--all-systems' to show)\n    \u2502   \u251c\u2500\u2500\u2500excalidraw-renderer omitted (use '--all-systems' to show)\n    \u2502   \u2514\u2500\u2500\u2500mkdocs-excalidraw omitted (use '--all-systems' to show)\n    \u2514\u2500\u2500\u2500x86_64-linux\n        \u251c\u2500\u2500\u2500beautifulsoup4: package 'python3.13-beautifulsoup4-4.13.5'\n        \u251c\u2500\u2500\u2500excalidraw-renderer: package 'excalidraw-renderer-0.6.0'\n        \u2514\u2500\u2500\u2500mkdocs-excalidraw: package 'mkdocs-excalidraw-0.6.0'\n</code></pre> <p>Each of these outputs can be found in <code>flake.nix</code>. For packages, you can search for <code>packages.&lt;package-name&gt;</code>. The development shell is defined at the bottom of the flake in <code>devShells.default</code>, with its packages defined in <code>buildInputs</code>.</p> <p>At time of writing, the default <code>devShell</code> includes the following packages:</p> <ul> <li><code>mkdocs</code></li> <li><code>python313Packages.mkdocs-material</code></li> <li><code>self'.packages.mkdocs-excalidraw</code></li> </ul> <p><code>self'.packages.mkdocs-excalidraw</code> refers to the package defined in our flake that builds the mkdocs-excalidraw plugin. This package builds the python code MKDocs uses to actually do the importing of excalidraw files. The <code>mkdocs-excalidraw</code> package we define is dependent on both the <code>excalidraw-renderer</code> and <code>beautifulsoup4</code> packages we define.</p> <p><code>excalidraw-renderer</code> builds the javascript code that the <code>mkdocs-excalidraw</code> python code calls into in order to actually render a <code>.excalidraw</code> file as a png. </p> <p><code>beautifulsoup4</code> is actually already packaged in nixpkgs, but the version that's packaged is too old for <code>mkdocs-excalidraw</code>, so all we do is tell Nix to use the definition already in nixpkgs but fetch &amp; build a newer version.</p>"},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/","title":"Architecture Spec","text":""},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#introduction","title":"Introduction","text":"<p>The architecture spec describes the overall intended design of the robot. This includes designs for the various algorithms and how various components should interact. This document should be readable without having any understanding of code, and should not be dependent on any particular code implementation.</p>"},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#ball-channel","title":"Ball Channel","text":"<p>DRIs</p> <ul> <li>Mayahuel ( Programming Lead )</li> <li>Alyssa (Programming)</li> </ul>"},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#picker","title":"Picker","text":"<p>DRIs</p> <ul> <li>Matthew ( Programming Lead )</li> <li>Austin ( Mechanical Lead )</li> </ul>"},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#shooter","title":"Shooter","text":"<p>DRIs</p> <ul> <li>Ibrahim ( Programming Lead )</li> </ul>"},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#climber","title":"Climber","text":"<p>DRIs</p> <ul> <li>Sophia (Programming Lead)</li> <li>Grace (Mechanical Lead)</li> </ul>"},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#swerve-drive","title":"Swerve Drive","text":"<p>DRIs</p> <ul> <li>Micah ( Programming Lead )</li> <li>Ibrahim ( Mentor )</li> </ul>"},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#swerve-drive-calibration-diagram","title":"Swerve Drive Calibration Diagram","text":""},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#swerve-drive-interaction-diagram","title":"Swerve Drive Interaction Diagram","text":""},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#swerve-drive-state-machine-diagram","title":"Swerve Drive State Machine Diagram","text":""},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#ball-counter","title":"Ball Counter","text":"<p>DRIs</p> <ul> <li>Matthew ( Programming Lead )</li> </ul>"},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#vision","title":"Vision","text":"<p>Upon being told to activate it will start running the validation code every time doPeriodic() is called. It modifies its private members, which get methods return; the get methods are the way for the other subsystems to get the values they need.</p>"},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#vision-state-diagram","title":"Vision State Diagram","text":"<p>Red boxes are states, blue boxes are what happens in that state. The blue boxes are connected to the state in which they describe. This State Diagram only describes what happens if the robot is trying to aim at the target, which is why it is only concerned about Retro Reflective Tape, the tape which is around the target. The white cylinders are places where data is stored.</p>"},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#subsytem-interactions-diagram","title":"Subsytem Interactions Diagram","text":"<p>This is an example of how all the code interacts. This specific example is for aiming at the target.</p>"},{"location":"Programming/Previous%20Robots/2022%20Offseason/top/#network-table-data","title":"Network Table Data","text":"<p>This describes all the data that is in the Network Table. Vision Rio both uses and modifies the data in the Network Table. The Network Table is the means by which the Pi Side and the Rio Side communicate to each other.</p> <p>DRIs</p> <ul> <li>Micah (Programming)</li> <li>Matthew (Programming)</li> </ul>"},{"location":"Programming/Previous%20Robots/2022%20Season/top/","title":"Architecture Spec","text":""},{"location":"Programming/Previous%20Robots/2022%20Season/top/#introduction","title":"Introduction","text":"<p>The architecture spec describes the overall intended design of the robot. This includes designs for the various algorithms and how various components should interact. This document should be readable without having any understanding of code, and should not be dependent on any particular code implementation.</p>"},{"location":"Programming/Previous%20Robots/2022%20Season/top/#example-subsystem-vcd-dumper","title":"Example Subsystem : VCD Dumper","text":"<p>The VCD Dumper is a debugging tool based on simulation tools used by digital hardware engineers. Essentially the VCD Dumper is designed to log values of important variables in a compressed file format. 1364 Verilog LRM</p> <p>DRIs</p> <ul> <li>Kareem (Programming Lead)</li> </ul> <p>Interface:  </p>"},{"location":"Programming/Previous%20Robots/2022%20Season/top/#ball-channel","title":"Ball Channel","text":"<p>DRIs</p> <ul> <li>Disha (Programming Lead)</li> <li>Alyssa (Programming)</li> <li>Austin (Mechanical Lead)</li> </ul>"},{"location":"Programming/Previous%20Robots/2022%20Season/top/#picker","title":"Picker","text":"<p>DRIs</p> <ul> <li>Sophia (Programming Lead)</li> <li>Kavya (Programming)</li> <li>Sanshubh (Programming)</li> <li>Theron (Mechanical Lead)</li> </ul>"},{"location":"Programming/Previous%20Robots/2022%20Season/top/#shooter","title":"Shooter","text":"<p>DRIs</p> <ul> <li>Sophia (Programming Lead)</li> <li>Kavya (Programming)</li> <li>Sanshubh (Programming)</li> <li>Cole (Mechanical Lead)</li> </ul>"},{"location":"Programming/Previous%20Robots/2022%20Season/top/#climber","title":"Climber","text":"<p>DRIs</p> <ul> <li>Disha (Programming Lead)</li> <li>Grace (Mechanical Lead)</li> </ul>"},{"location":"Programming/Previous%20Robots/2022%20Season/top/#drive-train","title":"Drive Train","text":"<p>DRIs </p> <ul> <li>Ibrahim</li> <li>Eddie</li> </ul>"},{"location":"Programming/Previous%20Robots/2022%20Season/top/#vision-rio","title":"Vision Rio","text":"<p>Upon being told to activate it will start running the validation code every time doPeriodic() is called. It modifies its private members, which get methods return; the get methods are the way for the other subsystems to get the values they need.</p>"},{"location":"Programming/Previous%20Robots/2022%20Season/top/#state-diagram","title":"State Diagram","text":"<p>Red boxes are states, blue boxes are what happens in that state. The blue boxes are connected to the state in which they describe. This State Diagram only describes what happens if the robot is trying to aim at the target, which is why it is only concerned about Retro Reflective Tape, the tape which is around the target. The white cylinders are places where data is stored.</p>"},{"location":"Programming/Previous%20Robots/2022%20Season/top/#interactions-diagram","title":"Interactions Diagram","text":"<p> This is an example of how all the code interacts. This specific example is for aiming at the target.</p>"},{"location":"Programming/Previous%20Robots/2022%20Season/top/#data-in-the-network-table","title":"Data In The Network Table","text":"<p>This describes all the data that is in the Network Table. Vision Rio both uses and modifies the data in the Network Table. The Network Table is the means by which the Pi Side and the Rio Side communicate to each other.</p> <p>DRIs</p> <ul> <li>Ibrahim (Programming Lead)</li> <li>Micah (Programming)</li> <li>Matthew (Programming)</li> </ul>"},{"location":"Programming/Previous%20Robots/2023%20Offseason/","title":"2023 Offseason - Imitator","text":"<p>The 2023 offseason robot does not have proper documentation, and there only exists a select few sequence diagrams detailing how each action should be performed. An example sequence diagram can is shown below.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2023%20Offseason/#home-to-ground-pick-cone","title":"Home to Ground Pick Cone","text":""},{"location":"Programming/Previous%20Robots/2023%20Offseason/#home-to-ground-pick-cube","title":"Home to Ground Pick Cube","text":""},{"location":"Programming/Previous%20Robots/2023%20Offseason/#home-to-human-feed","title":"Home to Human Feed","text":""},{"location":"Programming/Previous%20Robots/2023%20Offseason/#home-to-place","title":"Home to Place","text":""},{"location":"Programming/Previous%20Robots/2023%20Offseason/#to-home","title":"To Home","text":""},{"location":"Programming/Previous%20Robots/2023%20Season/top/","title":"Architecture Spec","text":""},{"location":"Programming/Previous%20Robots/2023%20Season/top/#introduction","title":"Introduction","text":"<p>The architecture spec describes the overall intended design of the robot. This includes designs for the various algorithms and how various components should interact. This document should be readable without having any understanding of code, and should not be dependent on any particular code implementation.</p>"},{"location":"Programming/Previous%20Robots/2023%20Season/top/#chamber","title":"Chamber","text":"<p>DRIs</p> <ul> <li>Sophia (Programming Lead)</li> <li>Anant (Programming)</li> <li>Sanshubh (Mechanical Lead)</li> </ul>"},{"location":"Programming/Previous%20Robots/2023%20Season/top/#grab-and-go","title":"Grab And Go","text":"<p>The GrabAndGo controlled the interactions among the other subsystems to automate the task of placing a game piece. This subsystem can be thought of like an orchestrator with each other subsystem being an instrument.  The individual subsystems do not know about how their actions affect the entire process. They follow the orchestrator who knows what the entire process is.  Let's run through a quick, simplified example of how a piece went from being on the ground to being placed:</p> <ul> <li>The driver presses the pick button, so the GrabAndGo tells the picker to come down, which will put the game piece into the chamber.</li> <li>Once the chamber senses the game piece, the GrabAndGo tells the arm to go into a position that grabs the game piece. The claw will also be told to open and close at the right time to grab the game piece.</li> <li>The GrabAndGo tells the arm to go into the \"transport\" position. The transport position is the position that allowed the robot to drive and have the game piece secured.</li> <li>When the driver presses the place button, the GrabAndGo will tell the arm to go to the placing position. GrabAndGo then waits for the driver to press the release game piece button.</li> <li>Once the driver presses the release game piece button, the GrabAndGo tells the claw to drop the game piece onto the target. Then the GrabAndGo tells the arm to go back to the home position.</li> </ul>"},{"location":"Programming/Previous%20Robots/2023%20Season/top/#state-diagram","title":"State Diagram","text":"<p>For diagram simplicity we split the diagram into two parts: one for cube and one for cone. The states that share the same  name are identical. The reason we did this was because of how many different arrows there would be within the diagram making  it more confusing to look at. </p>"},{"location":"Programming/Previous%20Robots/2023%20Season/top/#simplified-arm-positions-diagram","title":"Simplified Arm Positions Diagram","text":"<p>DRIs</p> <ul> <li>Micah (Programming Lead)</li> <li>Zayah (Programming)</li> </ul>"},{"location":"Programming/Previous%20Robots/2023%20Season/top/#vision-rio","title":"Vision Rio","text":"<p>Upon being told to activate it will start running the validation code every time doPeriodic() is called. It modifies its private members, which get methods return; the get methods are the way for the other subsystems to get the  values they need.</p>"},{"location":"Programming/Previous%20Robots/2023%20Season/top/#state-diagram_1","title":"State Diagram","text":"<p>Red boxes are states, blue boxes are what happens in that state. The blue boxes are connected to the state in which they  describe. This State Diagram only describes what happens if the robot is trying to aim at the target, which is why it is  only concerned about Retro Reflective Tape, the tape which is around the target. The white cylinders are places where data is stored.</p>"},{"location":"Programming/Previous%20Robots/2023%20Season/top/#interactions-diagram","title":"Interactions Diagram","text":"<p> This is an example of how all the code interacts. This specific example is for aiming at the target.</p>"},{"location":"Programming/Previous%20Robots/2023%20Season/top/#data-in-the-network-table","title":"Data In The Network Table","text":"<p>This describes all the data that is in the Network Table. Vision Rio both uses and modifies the data in the Network Table.  The Network Table is the means by which the Pi Side and the Rio Side communicate to each other.</p> <p>DRIs</p> <ul> <li>Ibrahim (Programming Lead)</li> <li>Micah (Programming)</li> <li>Matthew (Programming)</li> </ul>"},{"location":"Programming/Previous%20Robots/2023%20Season/top/#arm-extensionrotation","title":"Arm Extension/Rotation","text":"<p>DRIs</p> <ul> <li>Alyssa (Programming Lead)</li> <li>Cedar (Programming)</li> <li>Pierre (Programming)</li> </ul>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/","title":"Architecture Spec","text":""},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#introduction","title":"Introduction","text":"<p>The architecture spec describes the overall intended design of the 2024 Offseason robot (TatorSwift). This includes designs for the various algorithms and how various components should interact. This document should be readable without having any understanding of code, and should not be dependent on any particular code implementation.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#how-to-read-the-diagrams","title":"How to Read the Diagrams","text":"<p>The following diagrams can be understood through these example diagrams:</p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#state-machines","title":"State Machines","text":"<p>State Machines have a state, and can transition between states based on conditions or commands.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#sequences","title":"Sequences","text":"<p>Sequence Diagrams describe how different parts of the robot interact to preform a complicated action.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#gamepad","title":"Gamepad","text":"<p>For reference, here are the names of the buttons on a gamepad:</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#design-of-subsystems","title":"Design of Subsystems","text":""},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#picker","title":"Picker","text":"<p>The Picker can obtain notes on the ground from either side and feed them into the King Rollers.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#state-machine","title":"State Machine","text":""},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#sequence-diagram","title":"Sequence Diagram","text":""},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#directly-responsible-individuals","title":"Directly Responsible Individuals:","text":"<ul> <li>Cedar (Programming)</li> <li>Ian (Programming)</li> <li>Zach (Mechanical)</li> <li>Nate (Mechanical)</li> <li>Vedika (Mechanical)</li> </ul>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#king-rollers","title":"King Rollers","text":"<p>The King Rollers can hold a note from the Picker until it's ready to be fed into the Upper Note Path.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#state-machine_1","title":"State Machine","text":""},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#directly-responsible-individuals_1","title":"Directly Responsible Individuals:","text":"<ul> <li>Cedar (Programming)</li> <li>Ian (Programming)</li> <li>Tristan (Mechanical)</li> </ul>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#upper-note-path","title":"Upper Note Path","text":"<p>The Upper Note Path can take a note from the King Rollers, shoot it, or dunk it in the amp or trap.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#state-machine_2","title":"State Machine","text":"<p>Note that this state machine has extra elements: - Sub-state machines are smaller state machines controlled by the main state machine's states. Only up to one sub-state machine can be active at once. - The red diamonds are for indicating that a substate cannot be interrupted.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#sequence-diagrams","title":"Sequence Diagrams","text":"<ul> <li>Amp </li> <li>Trap </li> </ul>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#directly-responsible-individuals_2","title":"Directly Responsible Individuals:","text":"<ul> <li>Cedar (Programming)</li> <li>Ian (Programming)</li> <li>Tristan (Mechanical)</li> </ul>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#pivot","title":"Pivot","text":"<p>The Pivot can angle the Upper Note Path for shooting/amping/trapping.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#state-machine_3","title":"State Machine","text":""},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#directly-responsible-individuals_3","title":"Directly Responsible Individuals:","text":"<ul> <li>Cedar (Programming)</li> <li>Ian (Programming)</li> <li>Bentley (Mechanical)</li> <li>Tristan (Mechanical)</li> </ul>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#extension","title":"Extension","text":"<p>The Extension is mounted to the Upper Note Path and is used to carry a note out to the trap.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#state-machine_4","title":"State Machine","text":""},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#directly-responsible-individuals_4","title":"Directly Responsible Individuals:","text":"<ul> <li>Cedar (Programming)</li> <li>Ian (Programming)</li> <li>Nate (Mechanical)</li> </ul>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#climber","title":"Climber","text":"<p>The Climber can pull the robot up the chain on the Stage.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#state-machine_5","title":"State Machine","text":""},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#directly-responsible-individuals_5","title":"Directly Responsible Individuals:","text":"<ul> <li>Cedar (Programming)</li> <li>Ian (Programming)</li> <li>Esther (Mechanical)</li> <li>Omar (Mechanical)</li> </ul>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#drivetrain","title":"Drivetrain","text":"<p>The Drivetrain controls the swerve drive.</p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#state-machine_6","title":"State Machine","text":""},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#directly-responsible-individuals_6","title":"Directly Responsible Individuals:","text":"<ul> <li>Cedar (Programming)</li> <li>Ian (Programming)</li> <li>Ossian (Mechanical)</li> </ul>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#blinkin-leds","title":"Blinkin (LEDs)","text":"<p>The Blinkin LEDs are mounted to the outside of the robot and show the driver what the robot is doing at a glance.</p>"},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#flowchart","title":"Flowchart","text":""},{"location":"Programming/Previous%20Robots/2024%20Offseason/architecture/#network-tables","title":"Network Tables","text":"<p>The Network Tables are a system to communicate between the robot code and other devices, e.g. cameras and the Driver Station.^[more on Network Tables at the WPILib docs] </p>"},{"location":"Programming/Previous%20Robots/2024%20Season/","title":"Architecture Spec","text":""},{"location":"Programming/Previous%20Robots/2024%20Season/#introduction","title":"Introduction","text":"<p>The architecture spec describes the overall intended design of the 2025 competition robot (tidaltator). This includes designs for the various algorithms and how various components should interact. This document should be readable without having any understanding of code, and should not be dependent on any particular code implementation.</p>"},{"location":"Programming/Previous%20Robots/2024%20Season/#how-to-read-the-diagrams","title":"How to Read the Diagrams","text":"<p>The following diagrams can be understood through this example diagram:</p> <p>State Machines have a state, and can transition between states based on conditions or commands.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Season/#design-of-subsystems","title":"Design of Subsystems","text":""},{"location":"Programming/Previous%20Robots/2024%20Season/#affector","title":"Affector","text":"<p>The affector manipulates the note into the robot, and can then either feed the note into the shooter or in the reverse direction to score in the amp or trap.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Season/#arm-rotation","title":"Arm Rotation","text":"<p>The Arm Rotation subsystem rotates the arm on a pivot near the shooter.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Season/#picker","title":"Picker","text":"<p>The Picker subsystem grabs the notes from the ground and feeds them into the Affector.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2024%20Season/#shooter","title":"Shooter","text":"<p>The Shooter subsystem accepts notes from the Affector and shoots them into the speaker.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/","title":"Architecture Spec","text":""},{"location":"Programming/Previous%20Robots/2025%20Offseason/#introduction","title":"Introduction","text":"<p>The architecture spec describes the overall intended design of the 2025 off-season robot (aquatator). This includes designs for the various algorithms and how various components should interact. This document should be readable without having any understanding of code, and should not be dependent on any particular code implementation.</p>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/#how-to-read-the-diagrams","title":"How to Read the Diagrams","text":"<p>The following diagrams can be understood through these example diagrams:</p>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/#state-machines","title":"State Machines","text":"<p>State Machines have a state, and can transition between states based on conditions or commands.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/#sequences","title":"Sequences","text":"<p>Sequence Diagrams describe how different parts of the robot interact to perform a complicated action, and are implemented as command structures with the WPILib command based framework</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/#subsystems","title":"Subsystems","text":""},{"location":"Programming/Previous%20Robots/2025%20Offseason/#blinkin","title":"Blinkin","text":"<p>The Blinkin LEDs are mounted to the outside of the robot and show the drivers the status of the robot.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/#swerve-drive","title":"Swerve Drive","text":"<p>The Swerve Drive controls the swerve modules used to move the robot around.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/#chamber-of-corals","title":"Chamber of Corals","text":"<p>The Chamber of Corals processes coral from the picker to the affector.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/#overwatch","title":"Overwatch","text":"<p>The Overwatch takes the place of both the Lift and the Pivot, and navigates between set positions using A*.</p> <p>More on the Overwatch</p>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/#affector","title":"Affector","text":"<p>The Affector picks up the coral from the Chamber of Corals and then drops the coral on the reef. It also picks up algae.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/#coral-picker","title":"Coral Picker","text":"<p>The Coral Picker picks up coral and sends it to the Chamber of Corals.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/#climber","title":"Climber","text":"<p>The Climber holds onto the cage and lifts the robot off the ground.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/#algae-picker","title":"Algae Picker","text":"<p>The Algae Picker picks up algae and holds it in place for the affector</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/#sequences-diagramscommand-structures","title":"Sequences Diagrams/Command Structures","text":""},{"location":"Programming/Previous%20Robots/2025%20Offseason/#coral-picked-from-ground","title":"Coral Picked From Ground","text":""},{"location":"Programming/Previous%20Robots/2025%20Offseason/#coral-picked-from-station","title":"Coral Picked From Station","text":""},{"location":"Programming/Previous%20Robots/2025%20Offseason/#coral-place","title":"Coral Place","text":""},{"location":"Programming/Previous%20Robots/2025%20Offseason/overwatch/","title":"Overwatch","text":""},{"location":"Programming/Previous%20Robots/2025%20Offseason/overwatch/#overview","title":"Overview","text":"<ul> <li>The Overwatch directs the Lift and Pivot systems to follow a path from Point A to Point B.</li> <li>This path is determined by an A* algorithm and a set of known positions.   There is also an area defined as unsafe that paths cannot cross. This corresponds to other parts of the robot, e.g. the base, pickers, coral chamber, etc.</li> </ul> <p>An example node graph. The X axis is the pivot's angle, and the Y axis is the lift's height. The pivot can go in a circle, so the X axis can loop around.</p> <ul> <li>Clockwise/counterclockwise are as viewed from the right side of the robot (the side where the arm is closer than the lift)</li> </ul>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/overwatch/#api","title":"API","text":"<ul> <li><code>goTo(node[, direction])</code> is a method that returns a Command. It drives the lift and pivot to a specific <code>Node</code>. The direction can be specified to force the pivot to rotate either clockwise or counterclockwise to the destination.</li> <li><code>atGlobalSetpoint</code> is a Trigger that activates when the system is at the goal it's set to. You can use <code>atGlobalSetpoint.getAsBoolean()</code> to directly get a true/false value, or use it in any other way you can use a Trigger.</li> </ul>"},{"location":"Programming/Previous%20Robots/2025%20Offseason/overwatch/#moving","title":"Moving","text":"<ul> <li>The code first finds the optimal path from the current position (which may not be on a defined node) to the goal node.   The direction (clockwise or counterclockwise) can be forced to a specific one, or the code can find the shortest path and use that.</li> <li>Then, the edges between the nodes on the path are followed in sequence, by the pivot and lift simultaniously.</li> </ul> <p>Navigation between points. The fastest path between BAR and BAT is through BAZ, and the path from HOME to FOO goes through BIZ to avoid the danger zone.</p>"},{"location":"Programming/Previous%20Robots/2025%20Season/alphabot/architecture/","title":"Architecture Spec","text":""},{"location":"Programming/Previous%20Robots/2025%20Season/alphabot/architecture/#introduction","title":"Introduction","text":"<p>The architecture spec describes the overall intended design of the 2025 alpha robot (tidaltator alpha-develop branch). This includes designs for the various algorithms and how various components should interact. This document should be readable without having any understanding of code, and should not be dependent on any particular code implementation.</p>"},{"location":"Programming/Previous%20Robots/2025%20Season/alphabot/architecture/#how-to-read-the-diagrams","title":"How to Read the Diagrams","text":"<p>The following diagrams can be understood through these example diagrams:</p>"},{"location":"Programming/Previous%20Robots/2025%20Season/alphabot/architecture/#state-machines","title":"State Machines","text":"<p>State Machines have a state, and can transition between states based on conditions or commands.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/alphabot/architecture/#sequences","title":"Sequences","text":"<p>Sequence Diagrams describe how different parts of the robot interact to preform a complicated action.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/alphabot/architecture/#design-of-subsystems","title":"Design of Subsystems","text":""},{"location":"Programming/Previous%20Robots/2025%20Season/alphabot/architecture/#coral-affector","title":"Coral Affector","text":"<p>The Coral Affector can grab and release coral.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/alphabot/architecture/#drivetrain","title":"Drivetrain","text":"<p>The Drivetrain controls the swerve drive.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/alphabot/architecture/#pivot","title":"Pivot","text":"<p>The Pivot is the rotating arm on which the coral affector is mounted.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/alphabot/architecture/#algae-affector","title":"Algae Affector","text":"<p>The alpha bot doesn't have an algae affector, but this diagram was created before we were clear on the alpha bot's design.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/alphabot/architecture/#sequences_1","title":"Sequences","text":""},{"location":"Programming/Previous%20Robots/2025%20Season/alphabot/architecture/#pivot-sequence","title":"Pivot Sequence","text":"<p>The pivot sequence references a Lift subsystem, but the alpha bot has a fixed tower rather than a moveable lift.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/alphabot/architecture/#algae-sequence","title":"Algae Sequence","text":""},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/","title":"Architecture Spec","text":""},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#introduction","title":"Introduction","text":"<p>The architecture spec describes the overall intended design of the 2025 competition robot (tidaltator). This includes designs for the various algorithms and how various components should interact. This document should be readable without having any understanding of code, and should not be dependent on any particular code implementation.</p>"},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#how-to-read-the-diagrams","title":"How to Read the Diagrams","text":"<p>The following diagrams can be understood through these example diagrams:</p>"},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#state-machines","title":"State Machines","text":"<p>State Machines have a state, and can transition between states based on conditions or commands.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#sequences","title":"Sequences","text":"<p>Sequence Diagrams describe how different parts of the robot interact to perform a complicated action, and are implemented as command structures with the WPILib command based framework</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#design-of-subsystems","title":"Design of Subsystems","text":""},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#algae-holder","title":"Algae Holder","text":"<p>The Algae Holder is a stick that pops out to help control algae on the ground</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#algae-affector","title":"Algae Affector","text":"<p>The Algae Affector can grab and release algae.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#coral-affector","title":"Coral Affector","text":"<p>The Coral Affector can pick coral from the ground and place coral on the reef branches.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#elbow","title":"Elbow","text":"<p>The Elbow controls the angle of the forearm on which the Wrist and Coral Affector are mounted. The height of the Lift, and the angles of the Elbow and Wrist combine to put the Coral Affector in various positions for ground picking coral and placing coral at levels CORAL_L2 - CORAL_L4. #### State Machine </p>"},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#wrist","title":"Wrist","text":"<p>The Wrist extends and retracts the Coral Affector working with the Elbow and Lift. </p> <p> </p>"},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#drivetrain","title":"Drivetrain","text":"<p>The Drivetrain controls the swerve drive.</p>"},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#shift","title":"Shift","text":"<p>The Shift manages the Lift and Climber systems using the same motors.</p>"},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#lift","title":"Lift","text":"<p>The Lift moves the coralator and the algae affector up and down.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#climber","title":"Climber","text":"<p>The Climber can climb on a deep cage.</p> <p></p>"},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#sequences-diagramscommand-structures","title":"Sequences Diagrams/Command Structures","text":""},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#placement-of-algae-in-the-barge","title":"Placement of algae in the barge","text":""},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#placement-of-algae-in-the-processor","title":"Placement of algae in the processor","text":""},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#picking-of-algae-from-the-reef","title":"Picking of algae from the reef","text":""},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#robot-climbing-on-the-deep-cage","title":"Robot climbing on the deep cage","text":""},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#coral-picking","title":"Coral picking","text":""},{"location":"Programming/Previous%20Robots/2025%20Season/compbot/architecture/#placement-of-coral","title":"Placement of coral","text":""}]}